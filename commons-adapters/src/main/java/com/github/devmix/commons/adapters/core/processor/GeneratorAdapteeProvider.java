/*
 * Commons Library
 * Copyright (c) 2015-2016 Sergey Grachev (sergey.grachev@yahoo.com). All rights reserved.
 *
 * This software is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this software.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.github.devmix.commons.adapters.core.processor;

import com.github.devmix.commons.adapters.api.annotations.Adaptee;

import javax.annotation.Nullable;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.util.Types;
import java.io.IOException;

/**
 * @author Sergey Grachev
 */
final class GeneratorAdapteeProvider {

    public static final String DEFAULT_ADAPTEE_METHOD = "$adaptee";

    private final Types types;
    @Nullable
    private final ExecutableElement adapteeProviderMethod;
    private final DeclaredType adapterClassView;
    private final DeclaredType adapteeClassView;
    private final String adapteeMethodName;

    private Appendable buffer;

    public GeneratorAdapteeProvider(final Types types, @Nullable final ExecutableElement adapteeProviderMethod,
                                    final DeclaredType adapterClassView, final DeclaredType adapteeClassView) {
        this.types = types;
        this.adapteeProviderMethod = adapteeProviderMethod;
        this.adapterClassView = adapterClassView;
        this.adapteeClassView = adapteeClassView;
        this.adapteeMethodName = this.adapteeProviderMethod == null
                ? DEFAULT_ADAPTEE_METHOD : this.adapteeProviderMethod.getSimpleName().toString();
    }

    public void initialize(final Appendable buffer) {
        this.buffer = buffer;
    }

    public void write() throws IOException {
        if (adapteeProviderMethod != null) {
            return;
        }

        final String className = adapteeClassView.toString();
        final String annotationName = Adaptee.class.getCanonicalName();
        if (isAutoGeneratedAdaptee()) {
            buffer.append('@').append(annotationName).append(' ')
                    .append("public ").append(className).append(' ').append(adapteeMethodName).append("(){return this;}\n");
        } else {
            buffer.append("private ").append(className).append(' ').append(adapteeMethodName)
                    .append("=new ").append(className).append("();\n")

                    .append('@').append(annotationName).append(' ')
                    .append("public ").append(className).append(' ').append(adapteeMethodName)
                    .append("(){return this.").append(adapteeMethodName).append(";}\n");
        }
    }

    private boolean isAutoGeneratedAdaptee() {
        return ElementKind.INTERFACE.equals(adapteeClassView.asElement().getKind())
                || types.isSameType(adapterClassView, adapteeClassView);
    }

    public String toCode() {
        if (isAutoGeneratedAdaptee()) {
            return "this";
        }
        return "((" + adapteeClassView.toString() + ") this." + adapteeMethodName + "())";
    }

    public boolean isEquals(final Element method) {
        return adapteeProviderMethod != null && adapteeProviderMethod.equals(method);
    }
}
